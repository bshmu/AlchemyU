{"ast":null,"code":"/**\n *  A fragment is a single item from an ABI, which may represent any of:\n *\n *  - [Functions](FunctionFragment)\n *  - [Events](EventFragment)\n *  - [Constructors](ConstructorFragment)\n *  - Custom [Errors](ErrorFragment)\n *  - [Fallback or Receive](FallbackFragment) functions\n *\n *  @_subsection api/abi/abi-coder:Fragments  [about-fragments]\n */\nimport { defineProperties, getBigInt, getNumber, assert, assertPrivate, assertArgument } from \"../utils/index.js\";\nimport { id } from \"../hash/index.js\";\n;\n// [ \"a\", \"b\" ] => { \"a\": 1, \"b\": 1 }\nfunction setify(items) {\n  const result = new Set();\n  items.forEach(k => result.add(k));\n  return Object.freeze(result);\n}\nconst _kwVisibDeploy = \"external public payable\";\nconst KwVisibDeploy = setify(_kwVisibDeploy.split(\" \"));\n// Visibility Keywords\nconst _kwVisib = \"constant external internal payable private public pure view\";\nconst KwVisib = setify(_kwVisib.split(\" \"));\nconst _kwTypes = \"constructor error event fallback function receive struct\";\nconst KwTypes = setify(_kwTypes.split(\" \"));\nconst _kwModifiers = \"calldata memory storage payable indexed\";\nconst KwModifiers = setify(_kwModifiers.split(\" \"));\nconst _kwOther = \"tuple returns\";\n// All Keywords\nconst _keywords = [_kwTypes, _kwModifiers, _kwOther, _kwVisib].join(\" \");\nconst Keywords = setify(_keywords.split(\" \"));\n// Single character tokens\nconst SimpleTokens = {\n  \"(\": \"OPEN_PAREN\",\n  \")\": \"CLOSE_PAREN\",\n  \"[\": \"OPEN_BRACKET\",\n  \"]\": \"CLOSE_BRACKET\",\n  \",\": \"COMMA\",\n  \"@\": \"AT\"\n};\n// Parser regexes to consume the next token\nconst regexWhitespacePrefix = new RegExp(\"^(\\\\s*)\");\nconst regexNumberPrefix = new RegExp(\"^([0-9]+)\");\nconst regexIdPrefix = new RegExp(\"^([a-zA-Z$_][a-zA-Z0-9$_]*)\");\n// Parser regexs to check validity\nconst regexId = new RegExp(\"^([a-zA-Z$_][a-zA-Z0-9$_]*)$\");\nconst regexType = new RegExp(\"^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$\");\nclass TokenString {\n  #offset;\n  #tokens;\n  get offset() {\n    return this.#offset;\n  }\n  get length() {\n    return this.#tokens.length - this.#offset;\n  }\n  constructor(tokens) {\n    this.#offset = 0;\n    this.#tokens = tokens.slice();\n  }\n  clone() {\n    return new TokenString(this.#tokens);\n  }\n  reset() {\n    this.#offset = 0;\n  }\n  #subTokenString() {\n    let from = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return new TokenString(this.#tokens.slice(from, to).map(t => {\n      return Object.freeze(Object.assign({}, t, {\n        match: t.match - from,\n        linkBack: t.linkBack - from,\n        linkNext: t.linkNext - from\n      }));\n    }));\n  }\n  // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens\n  popKeyword(allowed) {\n    const top = this.peek();\n    if (top.type !== \"KEYWORD\" || !allowed.has(top.text)) {\n      throw new Error(`expected keyword ${top.text}`);\n    }\n    return this.pop().text;\n  }\n  // Pops and returns the value of the next token if it is `type`; throws if out of tokens\n  popType(type) {\n    if (this.peek().type !== type) {\n      throw new Error(`expected ${type}; got ${JSON.stringify(this.peek())}`);\n    }\n    return this.pop().text;\n  }\n  // Pops and returns a \"(\" TOKENS \")\"\n  popParen() {\n    const top = this.peek();\n    if (top.type !== \"OPEN_PAREN\") {\n      throw new Error(\"bad start\");\n    }\n    const result = this.#subTokenString(this.#offset + 1, top.match + 1);\n    this.#offset = top.match + 1;\n    return result;\n  }\n  // Pops and returns the items within \"(\" ITEM1 \",\" ITEM2 \",\" ... \")\"\n  popParams() {\n    const top = this.peek();\n    if (top.type !== \"OPEN_PAREN\") {\n      throw new Error(\"bad start\");\n    }\n    const result = [];\n    while (this.#offset < top.match - 1) {\n      const link = this.peek().linkNext;\n      result.push(this.#subTokenString(this.#offset + 1, link));\n      this.#offset = link;\n    }\n    this.#offset = top.match + 1;\n    return result;\n  }\n  // Returns the top Token, throwing if out of tokens\n  peek() {\n    if (this.#offset >= this.#tokens.length) {\n      throw new Error(\"out-of-bounds\");\n    }\n    return this.#tokens[this.#offset];\n  }\n  // Returns the next value, if it is a keyword in `allowed`\n  peekKeyword(allowed) {\n    const top = this.peekType(\"KEYWORD\");\n    return top != null && allowed.has(top) ? top : null;\n  }\n  // Returns the value of the next token if it is `type`\n  peekType(type) {\n    if (this.length === 0) {\n      return null;\n    }\n    const top = this.peek();\n    return top.type === type ? top.text : null;\n  }\n  // Returns the next token; throws if out of tokens\n  pop() {\n    const result = this.peek();\n    this.#offset++;\n    return result;\n  }\n  toString() {\n    const tokens = [];\n    for (let i = this.#offset; i < this.#tokens.length; i++) {\n      const token = this.#tokens[i];\n      tokens.push(`${token.type}:${token.text}`);\n    }\n    return `<TokenString ${tokens.join(\" \")}>`;\n  }\n}\nfunction lex(text) {\n  const tokens = [];\n  const throwError = message => {\n    const token = offset < text.length ? JSON.stringify(text[offset]) : \"$EOI\";\n    throw new Error(`invalid token ${token} at ${offset}: ${message}`);\n  };\n  let brackets = [];\n  let commas = [];\n  let offset = 0;\n  while (offset < text.length) {\n    // Strip off any leading whitespace\n    let cur = text.substring(offset);\n    let match = cur.match(regexWhitespacePrefix);\n    if (match) {\n      offset += match[1].length;\n      cur = text.substring(offset);\n    }\n    const token = {\n      depth: brackets.length,\n      linkBack: -1,\n      linkNext: -1,\n      match: -1,\n      type: \"\",\n      text: \"\",\n      offset,\n      value: -1\n    };\n    tokens.push(token);\n    let type = SimpleTokens[cur[0]] || \"\";\n    if (type) {\n      token.type = type;\n      token.text = cur[0];\n      offset++;\n      if (type === \"OPEN_PAREN\") {\n        brackets.push(tokens.length - 1);\n        commas.push(tokens.length - 1);\n      } else if (type == \"CLOSE_PAREN\") {\n        if (brackets.length === 0) {\n          throwError(\"no matching open bracket\");\n        }\n        token.match = brackets.pop();\n        tokens[token.match].match = tokens.length - 1;\n        token.depth--;\n        token.linkBack = commas.pop();\n        tokens[token.linkBack].linkNext = tokens.length - 1;\n      } else if (type === \"COMMA\") {\n        token.linkBack = commas.pop();\n        tokens[token.linkBack].linkNext = tokens.length - 1;\n        commas.push(tokens.length - 1);\n      } else if (type === \"OPEN_BRACKET\") {\n        token.type = \"BRACKET\";\n      } else if (type === \"CLOSE_BRACKET\") {\n        // Remove the CLOSE_BRACKET\n        let suffix = tokens.pop().text;\n        if (tokens.length > 0 && tokens[tokens.length - 1].type === \"NUMBER\") {\n          const value = tokens.pop().text;\n          suffix = value + suffix;\n          tokens[tokens.length - 1].value = getNumber(value);\n        }\n        if (tokens.length === 0 || tokens[tokens.length - 1].type !== \"BRACKET\") {\n          throw new Error(\"missing opening bracket\");\n        }\n        tokens[tokens.length - 1].text += suffix;\n      }\n      continue;\n    }\n    match = cur.match(regexIdPrefix);\n    if (match) {\n      token.text = match[1];\n      offset += token.text.length;\n      if (Keywords.has(token.text)) {\n        token.type = \"KEYWORD\";\n        continue;\n      }\n      if (token.text.match(regexType)) {\n        token.type = \"TYPE\";\n        continue;\n      }\n      token.type = \"ID\";\n      continue;\n    }\n    match = cur.match(regexNumberPrefix);\n    if (match) {\n      token.text = match[1];\n      token.type = \"NUMBER\";\n      offset += token.text.length;\n      continue;\n    }\n    throw new Error(`unexpected token ${JSON.stringify(cur[0])} at position ${offset}`);\n  }\n  return new TokenString(tokens.map(t => Object.freeze(t)));\n}\n// Check only one of `allowed` is in `set`\nfunction allowSingle(set, allowed) {\n  let included = [];\n  for (const key in allowed.keys()) {\n    if (set.has(key)) {\n      included.push(key);\n    }\n  }\n  if (included.length > 1) {\n    throw new Error(`conflicting types: ${included.join(\", \")}`);\n  }\n}\n// Functions to process a Solidity Signature TokenString from left-to-right for...\n// ...the name with an optional type, returning the name\nfunction consumeName(type, tokens) {\n  if (tokens.peekKeyword(KwTypes)) {\n    const keyword = tokens.pop().text;\n    if (keyword !== type) {\n      throw new Error(`expected ${type}, got ${keyword}`);\n    }\n  }\n  return tokens.popType(\"ID\");\n}\n// ...all keywords matching allowed, returning the keywords\nfunction consumeKeywords(tokens, allowed) {\n  const keywords = new Set();\n  while (true) {\n    const keyword = tokens.peekType(\"KEYWORD\");\n    if (keyword == null || allowed && !allowed.has(keyword)) {\n      break;\n    }\n    tokens.pop();\n    if (keywords.has(keyword)) {\n      throw new Error(`duplicate keywords: ${JSON.stringify(keyword)}`);\n    }\n    keywords.add(keyword);\n  }\n  return Object.freeze(keywords);\n}\n// ...all visibility keywords, returning the coalesced mutability\nfunction consumeMutability(tokens) {\n  let modifiers = consumeKeywords(tokens, KwVisib);\n  // Detect conflicting modifiers\n  allowSingle(modifiers, setify(\"constant payable nonpayable\".split(\" \")));\n  allowSingle(modifiers, setify(\"pure view payable nonpayable\".split(\" \")));\n  // Process mutability states\n  if (modifiers.has(\"view\")) {\n    return \"view\";\n  }\n  if (modifiers.has(\"pure\")) {\n    return \"pure\";\n  }\n  if (modifiers.has(\"payable\")) {\n    return \"payable\";\n  }\n  if (modifiers.has(\"nonpayable\")) {\n    return \"nonpayable\";\n  }\n  // Process legacy `constant` last\n  if (modifiers.has(\"constant\")) {\n    return \"view\";\n  }\n  return \"nonpayable\";\n}\n// ...a parameter list, returning the ParamType list\nfunction consumeParams(tokens, allowIndexed) {\n  return tokens.popParams().map(t => ParamType.from(t, allowIndexed));\n}\n// ...a gas limit, returning a BigNumber or null if none\nfunction consumeGas(tokens) {\n  if (tokens.peekType(\"AT\")) {\n    tokens.pop();\n    if (tokens.peekType(\"NUMBER\")) {\n      return getBigInt(tokens.pop().text);\n    }\n    throw new Error(\"invalid gas\");\n  }\n  return null;\n}\nfunction consumeEoi(tokens) {\n  if (tokens.length) {\n    throw new Error(`unexpected tokens: ${tokens.toString()}`);\n  }\n}\nconst regexArrayType = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\nfunction verifyBasicType(type) {\n  const match = type.match(regexType);\n  assertArgument(match, \"invalid type\", \"type\", type);\n  if (type === \"uint\") {\n    return \"uint256\";\n  }\n  if (type === \"int\") {\n    return \"int256\";\n  }\n  if (match[2]) {\n    // bytesXX\n    const length = parseInt(match[2]);\n    assertArgument(length !== 0 && length <= 32, \"invalid bytes length\", \"type\", type);\n  } else if (match[3]) {\n    // intXX or uintXX\n    const size = parseInt(match[3]);\n    assertArgument(size !== 0 && size <= 256 && size % 8 === 0, \"invalid numeric width\", \"type\", type);\n  }\n  return type;\n}\n// Make the Fragment constructors effectively private\nconst _guard = {};\nconst internal = Symbol.for(\"_ethers_internal\");\nconst ParamTypeInternal = \"_ParamTypeInternal\";\nconst ErrorFragmentInternal = \"_ErrorInternal\";\nconst EventFragmentInternal = \"_EventInternal\";\nconst ConstructorFragmentInternal = \"_ConstructorInternal\";\nconst FallbackFragmentInternal = \"_FallbackInternal\";\nconst FunctionFragmentInternal = \"_FunctionInternal\";\nconst StructFragmentInternal = \"_StructInternal\";\n/**\n *  Each input and output of a [[Fragment]] is an Array of **ParamType**.\n */\nexport class ParamType {\n  /**\n   *  The local name of the parameter (or ``\"\"`` if unbound)\n   */\n  name;\n  /**\n   *  The fully qualified type (e.g. ``\"address\"``, ``\"tuple(address)\"``,\n   *  ``\"uint256[3][]\"``)\n   */\n  type;\n  /**\n   *  The base type (e.g. ``\"address\"``, ``\"tuple\"``, ``\"array\"``)\n   */\n  baseType;\n  /**\n   *  True if the parameters is indexed.\n   *\n   *  For non-indexable types this is ``null``.\n   */\n  indexed;\n  /**\n   *  The components for the tuple.\n   *\n   *  For non-tuple types this is ``null``.\n   */\n  components;\n  /**\n   *  The array length, or ``-1`` for dynamic-lengthed arrays.\n   *\n   *  For non-array types this is ``null``.\n   */\n  arrayLength;\n  /**\n   *  The type of each child in the array.\n   *\n   *  For non-array types this is ``null``.\n   */\n  arrayChildren;\n  /**\n   *  @private\n   */\n  constructor(guard, name, type, baseType, indexed, components, arrayLength, arrayChildren) {\n    assertPrivate(guard, _guard, \"ParamType\");\n    Object.defineProperty(this, internal, {\n      value: ParamTypeInternal\n    });\n    if (components) {\n      components = Object.freeze(components.slice());\n    }\n    if (baseType === \"array\") {\n      if (arrayLength == null || arrayChildren == null) {\n        throw new Error(\"\");\n      }\n    } else if (arrayLength != null || arrayChildren != null) {\n      throw new Error(\"\");\n    }\n    if (baseType === \"tuple\") {\n      if (components == null) {\n        throw new Error(\"\");\n      }\n    } else if (components != null) {\n      throw new Error(\"\");\n    }\n    defineProperties(this, {\n      name,\n      type,\n      baseType,\n      indexed,\n      components,\n      arrayLength,\n      arrayChildren\n    });\n  }\n  /**\n   *  Return a string representation of this type.\n   *\n   *  For example,\n   *\n   *  ``sighash\" => \"(uint256,address)\"``\n   *\n   *  ``\"minimal\" => \"tuple(uint256,address) indexed\"``\n   *\n   *  ``\"full\" => \"tuple(uint256 foo, address bar) indexed baz\"``\n   */\n  format(format) {\n    if (format == null) {\n      format = \"sighash\";\n    }\n    if (format === \"json\") {\n      const name = this.name || \"\";\n      if (this.isArray()) {\n        const result = JSON.parse(this.arrayChildren.format(\"json\"));\n        result.name = name;\n        result.type += `[${this.arrayLength < 0 ? \"\" : String(this.arrayLength)}]`;\n        return JSON.stringify(result);\n      }\n      const result = {\n        type: this.baseType === \"tuple\" ? \"tuple\" : this.type,\n        name\n      };\n      if (typeof this.indexed === \"boolean\") {\n        result.indexed = this.indexed;\n      }\n      if (this.isTuple()) {\n        result.components = this.components.map(c => JSON.parse(c.format(format)));\n      }\n      return JSON.stringify(result);\n    }\n    let result = \"\";\n    // Array\n    if (this.isArray()) {\n      result += this.arrayChildren.format(format);\n      result += `[${this.arrayLength < 0 ? \"\" : String(this.arrayLength)}]`;\n    } else {\n      if (this.isTuple()) {\n        result += \"(\" + this.components.map(comp => comp.format(format)).join(format === \"full\" ? \", \" : \",\") + \")\";\n      } else {\n        result += this.type;\n      }\n    }\n    if (format !== \"sighash\") {\n      if (this.indexed === true) {\n        result += \" indexed\";\n      }\n      if (format === \"full\" && this.name) {\n        result += \" \" + this.name;\n      }\n    }\n    return result;\n  }\n  /**\n   *  Returns true if %%this%% is an Array type.\n   *\n   *  This provides a type gaurd ensuring that [[arrayChildren]]\n   *  and [[arrayLength]] are non-null.\n   */\n  isArray() {\n    return this.baseType === \"array\";\n  }\n  /**\n   *  Returns true if %%this%% is a Tuple type.\n   *\n   *  This provides a type gaurd ensuring that [[components]]\n   *  is non-null.\n   */\n  isTuple() {\n    return this.baseType === \"tuple\";\n  }\n  /**\n   *  Returns true if %%this%% is an Indexable type.\n   *\n   *  This provides a type gaurd ensuring that [[indexed]]\n   *  is non-null.\n   */\n  isIndexable() {\n    return this.indexed != null;\n  }\n  /**\n   *  Walks the **ParamType** with %%value%%, calling %%process%%\n   *  on each type, destructing the %%value%% recursively.\n   */\n  walk(value, process) {\n    if (this.isArray()) {\n      if (!Array.isArray(value)) {\n        throw new Error(\"invalid array value\");\n      }\n      if (this.arrayLength !== -1 && value.length !== this.arrayLength) {\n        throw new Error(\"array is wrong length\");\n      }\n      const _this = this;\n      return value.map(v => _this.arrayChildren.walk(v, process));\n    }\n    if (this.isTuple()) {\n      if (!Array.isArray(value)) {\n        throw new Error(\"invalid tuple value\");\n      }\n      if (value.length !== this.components.length) {\n        throw new Error(\"array is wrong length\");\n      }\n      const _this = this;\n      return value.map((v, i) => _this.components[i].walk(v, process));\n    }\n    return process(this.type, value);\n  }\n  #walkAsync(promises, value, process, setValue) {\n    if (this.isArray()) {\n      if (!Array.isArray(value)) {\n        throw new Error(\"invalid array value\");\n      }\n      if (this.arrayLength !== -1 && value.length !== this.arrayLength) {\n        throw new Error(\"array is wrong length\");\n      }\n      const childType = this.arrayChildren;\n      const result = value.slice();\n      result.forEach((value, index) => {\n        childType.#walkAsync(promises, value, process, value => {\n          result[index] = value;\n        });\n      });\n      setValue(result);\n      return;\n    }\n    if (this.isTuple()) {\n      const components = this.components;\n      // Convert the object into an array\n      let result;\n      if (Array.isArray(value)) {\n        result = value.slice();\n      } else {\n        if (value == null || typeof value !== \"object\") {\n          throw new Error(\"invalid tuple value\");\n        }\n        result = components.map(param => {\n          if (!param.name) {\n            throw new Error(\"cannot use object value with unnamed components\");\n          }\n          if (!(param.name in value)) {\n            throw new Error(`missing value for component ${param.name}`);\n          }\n          return value[param.name];\n        });\n      }\n      if (result.length !== this.components.length) {\n        throw new Error(\"array is wrong length\");\n      }\n      result.forEach((value, index) => {\n        components[index].#walkAsync(promises, value, process, value => {\n          result[index] = value;\n        });\n      });\n      setValue(result);\n      return;\n    }\n    const result = process(this.type, value);\n    if (result.then) {\n      promises.push(async function () {\n        setValue(await result);\n      }());\n    } else {\n      setValue(result);\n    }\n  }\n  /**\n   *  Walks the **ParamType** with %%value%%, asynchronously calling\n   *  %%process%% on each type, destructing the %%value%% recursively.\n   *\n   *  This can be used to resolve ENS naes by walking and resolving each\n   *  ``\"address\"`` type.\n   */\n  async walkAsync(value, process) {\n    const promises = [];\n    const result = [value];\n    this.#walkAsync(promises, value, process, value => {\n      result[0] = value;\n    });\n    if (promises.length) {\n      await Promise.all(promises);\n    }\n    return result[0];\n  }\n  /**\n   *  Creates a new **ParamType** for %%obj%%.\n   *\n   *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,\n   *  otherwise the ``indexed`` keyword will throw an error.\n   */\n  static from(obj, allowIndexed) {\n    if (ParamType.isParamType(obj)) {\n      return obj;\n    }\n    if (typeof obj === \"string\") {\n      try {\n        return ParamType.from(lex(obj), allowIndexed);\n      } catch (error) {\n        assertArgument(false, \"invalid param type\", \"obj\", obj);\n      }\n    } else if (obj instanceof TokenString) {\n      let type = \"\",\n        baseType = \"\";\n      let comps = null;\n      if (consumeKeywords(obj, setify([\"tuple\"])).has(\"tuple\") || obj.peekType(\"OPEN_PAREN\")) {\n        // Tuple\n        baseType = \"tuple\";\n        comps = obj.popParams().map(t => ParamType.from(t));\n        type = `tuple(${comps.map(c => c.format()).join(\",\")})`;\n      } else {\n        // Normal\n        type = verifyBasicType(obj.popType(\"TYPE\"));\n        baseType = type;\n      }\n      // Check for Array\n      let arrayChildren = null;\n      let arrayLength = null;\n      while (obj.length && obj.peekType(\"BRACKET\")) {\n        const bracket = obj.pop(); //arrays[i];\n        arrayChildren = new ParamType(_guard, \"\", type, baseType, null, comps, arrayLength, arrayChildren);\n        arrayLength = bracket.value;\n        type += bracket.text;\n        baseType = \"array\";\n        comps = null;\n      }\n      let indexed = null;\n      const keywords = consumeKeywords(obj, KwModifiers);\n      if (keywords.has(\"indexed\")) {\n        if (!allowIndexed) {\n          throw new Error(\"\");\n        }\n        indexed = true;\n      }\n      const name = obj.peekType(\"ID\") ? obj.pop().text : \"\";\n      if (obj.length) {\n        throw new Error(\"leftover tokens\");\n      }\n      return new ParamType(_guard, name, type, baseType, indexed, comps, arrayLength, arrayChildren);\n    }\n    const name = obj.name;\n    assertArgument(!name || typeof name === \"string\" && name.match(regexId), \"invalid name\", \"obj.name\", name);\n    let indexed = obj.indexed;\n    if (indexed != null) {\n      assertArgument(allowIndexed, \"parameter cannot be indexed\", \"obj.indexed\", obj.indexed);\n      indexed = !!indexed;\n    }\n    let type = obj.type;\n    let arrayMatch = type.match(regexArrayType);\n    if (arrayMatch) {\n      const arrayLength = parseInt(arrayMatch[2] || \"-1\");\n      const arrayChildren = ParamType.from({\n        type: arrayMatch[1],\n        components: obj.components\n      });\n      return new ParamType(_guard, name || \"\", type, \"array\", indexed, null, arrayLength, arrayChildren);\n    }\n    if (type === \"tuple\" || type.startsWith(\"tuple(\" /* fix: ) */) || type.startsWith(\"(\" /* fix: ) */)) {\n      const comps = obj.components != null ? obj.components.map(c => ParamType.from(c)) : null;\n      const tuple = new ParamType(_guard, name || \"\", type, \"tuple\", indexed, comps, null, null);\n      // @TODO: use lexer to validate and normalize type\n      return tuple;\n    }\n    type = verifyBasicType(obj.type);\n    return new ParamType(_guard, name || \"\", type, type, indexed, null, null, null);\n  }\n  /**\n   *  Returns true if %%value%% is a **ParamType**.\n   */\n  static isParamType(value) {\n    return value && value[internal] === ParamTypeInternal;\n  }\n}\n/**\n *  An abstract class to represent An individual fragment from a parse ABI.\n */\nexport class Fragment {\n  /**\n   *  The type of the fragment.\n   */\n  type;\n  /**\n   *  The inputs for the fragment.\n   */\n  inputs;\n  /**\n   *  @private\n   */\n  constructor(guard, type, inputs) {\n    assertPrivate(guard, _guard, \"Fragment\");\n    inputs = Object.freeze(inputs.slice());\n    defineProperties(this, {\n      type,\n      inputs\n    });\n  }\n  /**\n   *  Creates a new **Fragment** for %%obj%%, wich can be any supported\n   *  ABI frgament type.\n   */\n  static from(obj) {\n    if (typeof obj === \"string\") {\n      // Try parsing JSON...\n      try {\n        Fragment.from(JSON.parse(obj));\n      } catch (e) {}\n      // ...otherwise, use the human-readable lexer\n      return Fragment.from(lex(obj));\n    }\n    if (obj instanceof TokenString) {\n      // Human-readable ABI (already lexed)\n      const type = obj.peekKeyword(KwTypes);\n      switch (type) {\n        case \"constructor\":\n          return ConstructorFragment.from(obj);\n        case \"error\":\n          return ErrorFragment.from(obj);\n        case \"event\":\n          return EventFragment.from(obj);\n        case \"fallback\":\n        case \"receive\":\n          return FallbackFragment.from(obj);\n        case \"function\":\n          return FunctionFragment.from(obj);\n        case \"struct\":\n          return StructFragment.from(obj);\n      }\n    } else if (typeof obj === \"object\") {\n      // JSON ABI\n      switch (obj.type) {\n        case \"constructor\":\n          return ConstructorFragment.from(obj);\n        case \"error\":\n          return ErrorFragment.from(obj);\n        case \"event\":\n          return EventFragment.from(obj);\n        case \"fallback\":\n        case \"receive\":\n          return FallbackFragment.from(obj);\n        case \"function\":\n          return FunctionFragment.from(obj);\n        case \"struct\":\n          return StructFragment.from(obj);\n      }\n      assert(false, `unsupported type: ${obj.type}`, \"UNSUPPORTED_OPERATION\", {\n        operation: \"Fragment.from\"\n      });\n    }\n    assertArgument(false, \"unsupported frgament object\", \"obj\", obj);\n  }\n  /**\n   *  Returns true if %%value%% is a [[ConstructorFragment]].\n   */\n  static isConstructor(value) {\n    return ConstructorFragment.isFragment(value);\n  }\n  /**\n   *  Returns true if %%value%% is an [[ErrorFragment]].\n   */\n  static isError(value) {\n    return ErrorFragment.isFragment(value);\n  }\n  /**\n   *  Returns true if %%value%% is an [[EventFragment]].\n   */\n  static isEvent(value) {\n    return EventFragment.isFragment(value);\n  }\n  /**\n   *  Returns true if %%value%% is a [[FunctionFragment]].\n   */\n  static isFunction(value) {\n    return FunctionFragment.isFragment(value);\n  }\n  /**\n   *  Returns true if %%value%% is a [[StructFragment]].\n   */\n  static isStruct(value) {\n    return StructFragment.isFragment(value);\n  }\n}\n/**\n *  An abstract class to represent An individual fragment\n *  which has a name from a parse ABI.\n */\nexport class NamedFragment extends Fragment {\n  /**\n   *  The name of the fragment.\n   */\n  name;\n  /**\n   *  @private\n   */\n  constructor(guard, type, name, inputs) {\n    super(guard, type, inputs);\n    assertArgument(typeof name === \"string\" && name.match(regexId), \"invalid identifier\", \"name\", name);\n    inputs = Object.freeze(inputs.slice());\n    defineProperties(this, {\n      name\n    });\n  }\n}\nfunction joinParams(format, params) {\n  return \"(\" + params.map(p => p.format(format)).join(format === \"full\" ? \", \" : \",\") + \")\";\n}\n/**\n *  A Fragment which represents a //Custom Error//.\n */\nexport class ErrorFragment extends NamedFragment {\n  /**\n   *  @private\n   */\n  constructor(guard, name, inputs) {\n    super(guard, \"error\", name, inputs);\n    Object.defineProperty(this, internal, {\n      value: ErrorFragmentInternal\n    });\n  }\n  /**\n   *  The Custom Error selector.\n   */\n  get selector() {\n    return id(this.format(\"sighash\")).substring(0, 10);\n  }\n  /**\n   *  Returns a string representation of this fragment as %%format%%.\n   */\n  format(format) {\n    if (format == null) {\n      format = \"sighash\";\n    }\n    if (format === \"json\") {\n      return JSON.stringify({\n        type: \"error\",\n        name: this.name,\n        inputs: this.inputs.map(input => JSON.parse(input.format(format)))\n      });\n    }\n    const result = [];\n    if (format !== \"sighash\") {\n      result.push(\"error\");\n    }\n    result.push(this.name + joinParams(format, this.inputs));\n    return result.join(\" \");\n  }\n  /**\n   *  Returns a new **ErrorFragment** for %%obj%%.\n   */\n  static from(obj) {\n    if (ErrorFragment.isFragment(obj)) {\n      return obj;\n    }\n    if (typeof obj === \"string\") {\n      return ErrorFragment.from(lex(obj));\n    } else if (obj instanceof TokenString) {\n      const name = consumeName(\"error\", obj);\n      const inputs = consumeParams(obj);\n      consumeEoi(obj);\n      return new ErrorFragment(_guard, name, inputs);\n    }\n    return new ErrorFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);\n  }\n  /**\n   *  Returns ``true`` and provides a type guard if %%value%% is an\n   *  **ErrorFragment**.\n   */\n  static isFragment(value) {\n    return value && value[internal] === ErrorFragmentInternal;\n  }\n}\n/**\n *  A Fragment which represents an Event.\n */\nexport class EventFragment extends NamedFragment {\n  /**\n   *  Whether this event is anonymous.\n   */\n  anonymous;\n  /**\n   *  @private\n   */\n  constructor(guard, name, inputs, anonymous) {\n    super(guard, \"event\", name, inputs);\n    Object.defineProperty(this, internal, {\n      value: EventFragmentInternal\n    });\n    defineProperties(this, {\n      anonymous\n    });\n  }\n  /**\n   *  The Event topic hash.\n   */\n  get topicHash() {\n    return id(this.format(\"sighash\"));\n  }\n  /**\n   *  Returns a string representation of this event as %%format%%.\n   */\n  format(format) {\n    if (format == null) {\n      format = \"sighash\";\n    }\n    if (format === \"json\") {\n      return JSON.stringify({\n        type: \"event\",\n        anonymous: this.anonymous,\n        name: this.name,\n        inputs: this.inputs.map(i => JSON.parse(i.format(format)))\n      });\n    }\n    const result = [];\n    if (format !== \"sighash\") {\n      result.push(\"event\");\n    }\n    result.push(this.name + joinParams(format, this.inputs));\n    if (format !== \"sighash\" && this.anonymous) {\n      result.push(\"anonymous\");\n    }\n    return result.join(\" \");\n  }\n  /**\n   *  Return the topic hash for an event with %%name%% and %%params%%.\n   */\n  static getTopicHash(name, params) {\n    params = (params || []).map(p => ParamType.from(p));\n    const fragment = new EventFragment(_guard, name, params, false);\n    return fragment.topicHash;\n  }\n  /**\n   *  Returns a new **EventFragment** for %%obj%%.\n   */\n  static from(obj) {\n    if (EventFragment.isFragment(obj)) {\n      return obj;\n    }\n    if (typeof obj === \"string\") {\n      try {\n        return EventFragment.from(lex(obj));\n      } catch (error) {\n        assertArgument(false, \"invalid event fragment\", \"obj\", obj);\n      }\n    } else if (obj instanceof TokenString) {\n      const name = consumeName(\"event\", obj);\n      const inputs = consumeParams(obj, true);\n      const anonymous = !!consumeKeywords(obj, setify([\"anonymous\"])).has(\"anonymous\");\n      consumeEoi(obj);\n      return new EventFragment(_guard, name, inputs, anonymous);\n    }\n    return new EventFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(p => ParamType.from(p, true)) : [], !!obj.anonymous);\n  }\n  /**\n   *  Returns ``true`` and provides a type guard if %%value%% is an\n   *  **EventFragment**.\n   */\n  static isFragment(value) {\n    return value && value[internal] === EventFragmentInternal;\n  }\n}\n/**\n *  A Fragment which represents a constructor.\n */\nexport class ConstructorFragment extends Fragment {\n  /**\n   *  Whether the constructor can receive an endowment.\n   */\n  payable;\n  /**\n   *  The recommended gas limit for deployment or ``null``.\n   */\n  gas;\n  /**\n   *  @private\n   */\n  constructor(guard, type, inputs, payable, gas) {\n    super(guard, type, inputs);\n    Object.defineProperty(this, internal, {\n      value: ConstructorFragmentInternal\n    });\n    defineProperties(this, {\n      payable,\n      gas\n    });\n  }\n  /**\n   *  Returns a string representation of this constructor as %%format%%.\n   */\n  format(format) {\n    assert(format != null && format !== \"sighash\", \"cannot format a constructor for sighash\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"format(sighash)\"\n    });\n    if (format === \"json\") {\n      return JSON.stringify({\n        type: \"constructor\",\n        stateMutability: this.payable ? \"payable\" : \"undefined\",\n        payable: this.payable,\n        gas: this.gas != null ? this.gas : undefined,\n        inputs: this.inputs.map(i => JSON.parse(i.format(format)))\n      });\n    }\n    const result = [`constructor${joinParams(format, this.inputs)}`];\n    if (this.payable) {\n      result.push(\"payable\");\n    }\n    if (this.gas != null) {\n      result.push(`@${this.gas.toString()}`);\n    }\n    return result.join(\" \");\n  }\n  /**\n   *  Returns a new **ConstructorFragment** for %%obj%%.\n   */\n  static from(obj) {\n    if (ConstructorFragment.isFragment(obj)) {\n      return obj;\n    }\n    if (typeof obj === \"string\") {\n      try {\n        return ConstructorFragment.from(lex(obj));\n      } catch (error) {\n        assertArgument(false, \"invalid constuctor fragment\", \"obj\", obj);\n      }\n    } else if (obj instanceof TokenString) {\n      consumeKeywords(obj, setify([\"constructor\"]));\n      const inputs = consumeParams(obj);\n      const payable = !!consumeKeywords(obj, KwVisibDeploy).has(\"payable\");\n      const gas = consumeGas(obj);\n      consumeEoi(obj);\n      return new ConstructorFragment(_guard, \"constructor\", inputs, payable, gas);\n    }\n    return new ConstructorFragment(_guard, \"constructor\", obj.inputs ? obj.inputs.map(ParamType.from) : [], !!obj.payable, obj.gas != null ? obj.gas : null);\n  }\n  /**\n   *  Returns ``true`` and provides a type guard if %%value%% is a\n   *  **ConstructorFragment**.\n   */\n  static isFragment(value) {\n    return value && value[internal] === ConstructorFragmentInternal;\n  }\n}\n/**\n *  A Fragment which represents a method.\n */\nexport class FallbackFragment extends Fragment {\n  /**\n   *  If the function can be sent value during invocation.\n   */\n  payable;\n  constructor(guard, inputs, payable) {\n    super(guard, \"fallback\", inputs);\n    Object.defineProperty(this, internal, {\n      value: FallbackFragmentInternal\n    });\n    defineProperties(this, {\n      payable\n    });\n  }\n  /**\n   *  Returns a string representation of this fallback as %%format%%.\n   */\n  format(format) {\n    const type = this.inputs.length === 0 ? \"receive\" : \"fallback\";\n    if (format === \"json\") {\n      const stateMutability = this.payable ? \"payable\" : \"nonpayable\";\n      return JSON.stringify({\n        type,\n        stateMutability\n      });\n    }\n    return `${type}()${this.payable ? \" payable\" : \"\"}`;\n  }\n  /**\n   *  Returns a new **FallbackFragment** for %%obj%%.\n   */\n  static from(obj) {\n    if (FallbackFragment.isFragment(obj)) {\n      return obj;\n    }\n    if (typeof obj === \"string\") {\n      try {\n        return FallbackFragment.from(lex(obj));\n      } catch (error) {\n        assertArgument(false, \"invalid fallback fragment\", \"obj\", obj);\n      }\n    } else if (obj instanceof TokenString) {\n      const errorObj = obj.toString();\n      const topIsValid = obj.peekKeyword(setify([\"fallback\", \"receive\"]));\n      assertArgument(topIsValid, \"type must be fallback or receive\", \"obj\", errorObj);\n      const type = obj.popKeyword(setify([\"fallback\", \"receive\"]));\n      // receive()\n      if (type === \"receive\") {\n        const inputs = consumeParams(obj);\n        assertArgument(inputs.length === 0, `receive cannot have arguments`, \"obj.inputs\", inputs);\n        consumeKeywords(obj, setify([\"payable\"]));\n        consumeEoi(obj);\n        return new FallbackFragment(_guard, [], true);\n      }\n      // fallback() [payable]\n      // fallback(bytes) [payable] returns (bytes)\n      let inputs = consumeParams(obj);\n      if (inputs.length) {\n        assertArgument(inputs.length === 1 && inputs[0].type === \"bytes\", \"invalid fallback inputs\", \"obj.inputs\", inputs.map(i => i.format(\"minimal\")).join(\", \"));\n      } else {\n        inputs = [ParamType.from(\"bytes\")];\n      }\n      const mutability = consumeMutability(obj);\n      assertArgument(mutability === \"nonpayable\" || mutability === \"payable\", \"fallback cannot be constants\", \"obj.stateMutability\", mutability);\n      if (consumeKeywords(obj, setify([\"returns\"])).has(\"returns\")) {\n        const outputs = consumeParams(obj);\n        assertArgument(outputs.length === 1 && outputs[0].type === \"bytes\", \"invalid fallback outputs\", \"obj.outputs\", outputs.map(i => i.format(\"minimal\")).join(\", \"));\n      }\n      consumeEoi(obj);\n      return new FallbackFragment(_guard, inputs, mutability === \"payable\");\n    }\n    if (obj.type === \"receive\") {\n      return new FallbackFragment(_guard, [], true);\n    }\n    if (obj.type === \"fallback\") {\n      const inputs = [ParamType.from(\"bytes\")];\n      const payable = obj.stateMutability === \"payable\";\n      return new FallbackFragment(_guard, inputs, payable);\n    }\n    assertArgument(false, \"invalid fallback description\", \"obj\", obj);\n  }\n  /**\n   *  Returns ``true`` and provides a type guard if %%value%% is a\n   *  **FallbackFragment**.\n   */\n  static isFragment(value) {\n    return value && value[internal] === FallbackFragmentInternal;\n  }\n}\n/**\n *  A Fragment which represents a method.\n */\nexport class FunctionFragment extends NamedFragment {\n  /**\n   *  If the function is constant (e.g. ``pure`` or ``view`` functions).\n   */\n  constant;\n  /**\n   *  The returned types for the result of calling this function.\n   */\n  outputs;\n  /**\n   *  The state mutability (e.g. ``payable``, ``nonpayable``, ``view``\n   *  or ``pure``)\n   */\n  stateMutability;\n  /**\n   *  If the function can be sent value during invocation.\n   */\n  payable;\n  /**\n   *  The recommended gas limit to send when calling this function.\n   */\n  gas;\n  /**\n   *  @private\n   */\n  constructor(guard, name, stateMutability, inputs, outputs, gas) {\n    super(guard, \"function\", name, inputs);\n    Object.defineProperty(this, internal, {\n      value: FunctionFragmentInternal\n    });\n    outputs = Object.freeze(outputs.slice());\n    const constant = stateMutability === \"view\" || stateMutability === \"pure\";\n    const payable = stateMutability === \"payable\";\n    defineProperties(this, {\n      constant,\n      gas,\n      outputs,\n      payable,\n      stateMutability\n    });\n  }\n  /**\n   *  The Function selector.\n   */\n  get selector() {\n    return id(this.format(\"sighash\")).substring(0, 10);\n  }\n  /**\n   *  Returns a string representation of this function as %%format%%.\n   */\n  format(format) {\n    if (format == null) {\n      format = \"sighash\";\n    }\n    if (format === \"json\") {\n      return JSON.stringify({\n        type: \"function\",\n        name: this.name,\n        constant: this.constant,\n        stateMutability: this.stateMutability !== \"nonpayable\" ? this.stateMutability : undefined,\n        payable: this.payable,\n        gas: this.gas != null ? this.gas : undefined,\n        inputs: this.inputs.map(i => JSON.parse(i.format(format))),\n        outputs: this.outputs.map(o => JSON.parse(o.format(format)))\n      });\n    }\n    const result = [];\n    if (format !== \"sighash\") {\n      result.push(\"function\");\n    }\n    result.push(this.name + joinParams(format, this.inputs));\n    if (format !== \"sighash\") {\n      if (this.stateMutability !== \"nonpayable\") {\n        result.push(this.stateMutability);\n      }\n      if (this.outputs && this.outputs.length) {\n        result.push(\"returns\");\n        result.push(joinParams(format, this.outputs));\n      }\n      if (this.gas != null) {\n        result.push(`@${this.gas.toString()}`);\n      }\n    }\n    return result.join(\" \");\n  }\n  /**\n   *  Return the selector for a function with %%name%% and %%params%%.\n   */\n  static getSelector(name, params) {\n    params = (params || []).map(p => ParamType.from(p));\n    const fragment = new FunctionFragment(_guard, name, \"view\", params, [], null);\n    return fragment.selector;\n  }\n  /**\n   *  Returns a new **FunctionFragment** for %%obj%%.\n   */\n  static from(obj) {\n    if (FunctionFragment.isFragment(obj)) {\n      return obj;\n    }\n    if (typeof obj === \"string\") {\n      try {\n        return FunctionFragment.from(lex(obj));\n      } catch (error) {\n        assertArgument(false, \"invalid function fragment\", \"obj\", obj);\n      }\n    } else if (obj instanceof TokenString) {\n      const name = consumeName(\"function\", obj);\n      const inputs = consumeParams(obj);\n      const mutability = consumeMutability(obj);\n      let outputs = [];\n      if (consumeKeywords(obj, setify([\"returns\"])).has(\"returns\")) {\n        outputs = consumeParams(obj);\n      }\n      const gas = consumeGas(obj);\n      consumeEoi(obj);\n      return new FunctionFragment(_guard, name, mutability, inputs, outputs, gas);\n    }\n    let stateMutability = obj.stateMutability;\n    // Use legacy Solidity ABI logic if stateMutability is missing\n    if (stateMutability == null) {\n      stateMutability = \"payable\";\n      if (typeof obj.constant === \"boolean\") {\n        stateMutability = \"view\";\n        if (!obj.constant) {\n          stateMutability = \"payable\";\n          if (typeof obj.payable === \"boolean\" && !obj.payable) {\n            stateMutability = \"nonpayable\";\n          }\n        }\n      } else if (typeof obj.payable === \"boolean\" && !obj.payable) {\n        stateMutability = \"nonpayable\";\n      }\n    }\n    // @TODO: verifyState for stateMutability (e.g. throw if\n    //        payable: false but stateMutability is \"nonpayable\")\n    return new FunctionFragment(_guard, obj.name, stateMutability, obj.inputs ? obj.inputs.map(ParamType.from) : [], obj.outputs ? obj.outputs.map(ParamType.from) : [], obj.gas != null ? obj.gas : null);\n  }\n  /**\n   *  Returns ``true`` and provides a type guard if %%value%% is a\n   *  **FunctionFragment**.\n   */\n  static isFragment(value) {\n    return value && value[internal] === FunctionFragmentInternal;\n  }\n}\n/**\n *  A Fragment which represents a structure.\n */\nexport class StructFragment extends NamedFragment {\n  /**\n   *  @private\n   */\n  constructor(guard, name, inputs) {\n    super(guard, \"struct\", name, inputs);\n    Object.defineProperty(this, internal, {\n      value: StructFragmentInternal\n    });\n  }\n  /**\n   *  Returns a string representation of this struct as %%format%%.\n   */\n  format() {\n    throw new Error(\"@TODO\");\n  }\n  /**\n   *  Returns a new **StructFragment** for %%obj%%.\n   */\n  static from(obj) {\n    if (typeof obj === \"string\") {\n      try {\n        return StructFragment.from(lex(obj));\n      } catch (error) {\n        assertArgument(false, \"invalid struct fragment\", \"obj\", obj);\n      }\n    } else if (obj instanceof TokenString) {\n      const name = consumeName(\"struct\", obj);\n      const inputs = consumeParams(obj);\n      consumeEoi(obj);\n      return new StructFragment(_guard, name, inputs);\n    }\n    return new StructFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);\n  }\n  // @TODO: fix this return type\n  /**\n   *  Returns ``true`` and provides a type guard if %%value%% is a\n   *  **StructFragment**.\n   */\n  static isFragment(value) {\n    return value && value[internal] === StructFragmentInternal;\n  }\n}","map":{"version":3,"mappings":"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","names":["defineProperties","getBigInt","getNumber","assert","assertPrivate","assertArgument","id","setify","items","result","Set","forEach","k","add","Object","freeze","_kwVisibDeploy","KwVisibDeploy","split","_kwVisib","KwVisib","_kwTypes","KwTypes","_kwModifiers","KwModifiers","_kwOther","_keywords","join","Keywords","SimpleTokens","regexWhitespacePrefix","RegExp","regexNumberPrefix","regexIdPrefix","regexId","regexType","TokenString","offset","length","constructor","tokens","slice","clone","reset","from","to","map","t","assign","match","linkBack","linkNext","popKeyword","allowed","top","peek","type","has","text","Error","pop","popType","JSON","stringify","popParen","popParams","link","push","peekKeyword","peekType","toString","i","token","lex","throwError","message","brackets","commas","cur","substring","depth","value","suffix","allowSingle","set","included","key","keys","consumeName","keyword","consumeKeywords","keywords","consumeMutability","modifiers","consumeParams","allowIndexed","ParamType","consumeGas","consumeEoi","regexArrayType","verifyBasicType","parseInt","size","_guard","internal","Symbol","for","ParamTypeInternal","ErrorFragmentInternal","EventFragmentInternal","ConstructorFragmentInternal","FallbackFragmentInternal","FunctionFragmentInternal","StructFragmentInternal","name","baseType","indexed","components","arrayLength","arrayChildren","guard","defineProperty","format","isArray","parse","String","isTuple","c","comp","isIndexable","walk","process","Array","_this","v","promises","setValue","childType","index","param","then","walkAsync","Promise","all","obj","isParamType","error","comps","bracket","arrayMatch","startsWith","tuple","Fragment","inputs","e","ConstructorFragment","ErrorFragment","EventFragment","FallbackFragment","FunctionFragment","StructFragment","operation","isConstructor","isFragment","isError","isEvent","isFunction","isStruct","NamedFragment","joinParams","params","p","selector","input","anonymous","topicHash","getTopicHash","fragment","payable","gas","stateMutability","undefined","errorObj","topIsValid","mutability","outputs","constant","o","getSelector"],"sources":["/Users/benjaminshmulevsky/repos/alchemyu/ethereum-block-explorer/node_modules/ethers/src.ts/abi/fragments.ts"],"sourcesContent":["/**\n *  A fragment is a single item from an ABI, which may represent any of:\n *\n *  - [Functions](FunctionFragment)\n *  - [Events](EventFragment)\n *  - [Constructors](ConstructorFragment)\n *  - Custom [Errors](ErrorFragment)\n *  - [Fallback or Receive](FallbackFragment) functions\n *\n *  @_subsection api/abi/abi-coder:Fragments  [about-fragments]\n */\n\nimport {\n    defineProperties, getBigInt, getNumber,\n    assert, assertPrivate, assertArgument\n} from \"../utils/index.js\";\nimport { id } from \"../hash/index.js\";\n\n/**\n *  A Type description in a [JSON ABI format](link-solc-jsonabi).\n */\nexport interface JsonFragmentType {\n    /**\n     *  The parameter name.\n     */\n    readonly name?: string;\n\n    /**\n     *  If the parameter is indexed.\n     */\n    readonly indexed?: boolean;\n\n    /**\n     *  The type of the parameter.\n     */\n    readonly type?: string;\n\n    /**\n     *  The internal Solidity type.\n     */\n    readonly internalType?: string;\n\n    /**\n     *  The components for a tuple.\n     */\n    readonly components?: ReadonlyArray<JsonFragmentType>;\n}\n\n/**\n *  A fragment for a method, event or error in a [JSON ABI format](link-solc-jsonabi).\n */\nexport interface JsonFragment {\n    /**\n     *  The name of the error, event, function, etc.\n     */\n    readonly name?: string;\n\n    /**\n     *  The type of the fragment (e.g. ``event``, ``\"function\"``, etc.)\n     */\n    readonly type?: string;\n\n    /**\n     *  If the event is anonymous.\n     */\n    readonly anonymous?: boolean;\n\n    /**\n     *  If the function is payable.\n     */\n    readonly payable?: boolean;\n\n    /**\n     *  If the function is constant.\n     */\n    readonly constant?: boolean;\n\n    /**\n     *  The mutability state of the function.\n     */\n    readonly stateMutability?: string;\n\n    /**\n     *  The input parameters.\n     */\n    readonly inputs?: ReadonlyArray<JsonFragmentType>;\n\n    /**\n     *  The output parameters.\n     */\n    readonly outputs?: ReadonlyArray<JsonFragmentType>;\n\n    /**\n     *  The gas limit to use when sending a transaction for this function.\n     */\n    readonly gas?: string;\n};\n\n/**\n *  The format to serialize the output as.\n *\n *  **``\"sighash\"``** - the bare formatting, used to compute the selector\n *  or topic hash; this format cannot be reversed (as it discards ``indexed``)\n *  so cannot by used to export an [[Interface]].\n *\n *  **``\"minimal\"``** - Human-Readable ABI with minimal spacing and without\n *  names, so it is compact, but will result in Result objects that cannot\n *  be accessed by name.\n *\n *  **``\"full\"``** - Full Human-Readable ABI, with readable spacing and names\n *  intact; this is generally the recommended format.\n *\n *  **``\"json\"``** - The [JSON ABI format](link-solc-jsonabi).\n */\nexport type FormatType = \"sighash\" | \"minimal\" | \"full\" | \"json\";\n\n// [ \"a\", \"b\" ] => { \"a\": 1, \"b\": 1 }\nfunction setify(items: Array<string>): ReadonlySet<string> {\n    const result: Set<string> = new Set();\n    items.forEach((k) => result.add(k));\n    return Object.freeze(result);\n}\n\nconst _kwVisibDeploy = \"external public payable\";\nconst KwVisibDeploy = setify(_kwVisibDeploy.split(\" \"));\n\n// Visibility Keywords\nconst _kwVisib = \"constant external internal payable private public pure view\";\nconst KwVisib = setify(_kwVisib.split(\" \"));\n\nconst _kwTypes = \"constructor error event fallback function receive struct\";\nconst KwTypes = setify(_kwTypes.split(\" \"));\n\nconst _kwModifiers = \"calldata memory storage payable indexed\";\nconst KwModifiers = setify(_kwModifiers.split(\" \"));\n\nconst _kwOther = \"tuple returns\";\n\n// All Keywords\nconst _keywords = [ _kwTypes, _kwModifiers, _kwOther, _kwVisib ].join(\" \");\nconst Keywords = setify(_keywords.split(\" \"));\n\n// Single character tokens\nconst SimpleTokens: Record<string, string> = {\n  \"(\": \"OPEN_PAREN\", \")\": \"CLOSE_PAREN\",\n  \"[\": \"OPEN_BRACKET\", \"]\": \"CLOSE_BRACKET\",\n  \",\": \"COMMA\", \"@\": \"AT\"\n};\n\n// Parser regexes to consume the next token\nconst regexWhitespacePrefix = new RegExp(\"^(\\\\s*)\");\nconst regexNumberPrefix = new RegExp(\"^([0-9]+)\");\nconst regexIdPrefix = new RegExp(\"^([a-zA-Z$_][a-zA-Z0-9$_]*)\");\n\n// Parser regexs to check validity\nconst regexId = new RegExp(\"^([a-zA-Z$_][a-zA-Z0-9$_]*)$\");\nconst regexType = new RegExp(\"^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$\");\n\n/**\n *  @ignore:\n */\ntype Token = Readonly<{\n    // Type of token (e.g. TYPE, KEYWORD, NUMBER, etc)\n    type: string;\n\n    // Offset into the original source code\n    offset: number;\n\n    // Actual text content of the token\n    text: string;\n\n    // The parenthesis depth\n    depth: number;\n\n    // If a parenthesis, the offset (in tokens) that balances it\n    match: number;\n\n    // For parenthesis and commas, the offset (in tokens) to the\n    // previous/next parenthesis or comma in the list\n    linkBack: number;\n    linkNext: number;\n\n    // If a BRACKET, the value inside\n    value: number;\n}>;\n\nclass TokenString {\n    #offset: number;\n    #tokens: ReadonlyArray<Token>;\n\n    get offset(): number { return this.#offset; }\n    get length(): number { return this.#tokens.length - this.#offset; }\n\n    constructor(tokens: ReadonlyArray<Token>) {\n        this.#offset = 0;\n        this.#tokens = tokens.slice();\n    }\n\n    clone(): TokenString { return new TokenString(this.#tokens); }\n    reset(): void { this.#offset = 0; }\n\n    #subTokenString(from: number = 0, to: number = 0): TokenString {\n        return new TokenString(this.#tokens.slice(from, to).map((t) => {\n            return Object.freeze(Object.assign({ }, t, {\n                match: (t.match - from),\n                linkBack: (t.linkBack - from),\n                linkNext: (t.linkNext - from),\n            }));\n        }));\n    }\n\n    // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens\n    popKeyword(allowed: ReadonlySet<string>): string {\n        const top = this.peek();\n        if (top.type !== \"KEYWORD\" || !allowed.has(top.text)) { throw new Error(`expected keyword ${ top.text }`); }\n        return this.pop().text;\n    }\n\n    // Pops and returns the value of the next token if it is `type`; throws if out of tokens\n    popType(type: string): string {\n        if (this.peek().type !== type) { throw new Error(`expected ${ type }; got ${ JSON.stringify(this.peek()) }`); }\n        return this.pop().text;\n    }\n\n    // Pops and returns a \"(\" TOKENS \")\"\n    popParen(): TokenString {\n        const top = this.peek();\n        if (top.type !== \"OPEN_PAREN\") { throw new Error(\"bad start\"); }\n        const result = this.#subTokenString(this.#offset + 1, top.match + 1);\n        this.#offset = top.match + 1;\n        return result;\n    }\n\n    // Pops and returns the items within \"(\" ITEM1 \",\" ITEM2 \",\" ... \")\"\n    popParams(): Array<TokenString> {\n        const top = this.peek();\n\n        if (top.type !== \"OPEN_PAREN\") { throw new Error(\"bad start\"); }\n\n        const result: Array<TokenString> = [ ];\n\n        while(this.#offset < top.match - 1) {\n            const link = this.peek().linkNext;\n            result.push(this.#subTokenString(this.#offset + 1, link));\n            this.#offset = link;\n        }\n\n        this.#offset = top.match + 1;\n\n        return result;\n    }\n\n    // Returns the top Token, throwing if out of tokens\n    peek(): Token {\n        if (this.#offset >= this.#tokens.length) {\n            throw new Error(\"out-of-bounds\");\n        }\n        return this.#tokens[this.#offset];\n    }\n\n    // Returns the next value, if it is a keyword in `allowed`\n    peekKeyword(allowed: ReadonlySet<string>): null | string {\n        const top = this.peekType(\"KEYWORD\");\n        return (top != null && allowed.has(top)) ? top: null;\n    }\n\n    // Returns the value of the next token if it is `type`\n    peekType(type: string): null | string {\n        if (this.length === 0) { return null; }\n        const top = this.peek();\n        return (top.type === type) ? top.text: null;\n    }\n\n    // Returns the next token; throws if out of tokens\n    pop(): Token {\n        const result = this.peek();\n        this.#offset++;\n        return result;\n    }\n\n    toString(): string {\n        const tokens: Array<string> = [ ];\n        for (let i = this.#offset; i < this.#tokens.length; i++) {\n            const token = this.#tokens[i];\n            tokens.push(`${ token.type }:${ token.text }`);\n        }\n        return `<TokenString ${ tokens.join(\" \") }>`\n    }\n}\n\ntype Writeable<T> = { -readonly [P in keyof T]: T[P] };\n\nfunction lex(text: string): TokenString {\n    const tokens: Array<Token> = [ ];\n\n    const throwError = (message: string) => {\n        const token = (offset < text.length) ? JSON.stringify(text[offset]): \"$EOI\";\n        throw new Error(`invalid token ${ token } at ${ offset }: ${ message }`);\n    };\n\n    let brackets: Array<number> = [ ];\n    let commas: Array<number> = [ ];\n\n    let offset = 0;\n    while (offset < text.length) {\n\n        // Strip off any leading whitespace\n        let cur = text.substring(offset);\n        let match = cur.match(regexWhitespacePrefix);\n        if (match) {\n            offset += match[1].length;\n            cur = text.substring(offset);\n        }\n\n        const token = { depth: brackets.length, linkBack: -1, linkNext: -1, match: -1, type: \"\", text: \"\", offset, value: -1 };\n        tokens.push(token);\n\n        let type = (SimpleTokens[cur[0]] || \"\");\n        if (type) {\n            token.type = type;\n            token.text = cur[0];\n            offset++;\n\n            if (type === \"OPEN_PAREN\") {\n                brackets.push(tokens.length - 1);\n                commas.push(tokens.length - 1);\n\n            } else if (type == \"CLOSE_PAREN\") {\n                if (brackets.length === 0) { throwError(\"no matching open bracket\"); }\n\n                token.match = brackets.pop() as number;\n                (<Writeable<Token>>(tokens[token.match])).match = tokens.length - 1;\n                token.depth--;\n\n                token.linkBack = commas.pop() as number;\n                (<Writeable<Token>>(tokens[token.linkBack])).linkNext = tokens.length - 1;\n\n            } else if (type === \"COMMA\") {\n                token.linkBack = commas.pop() as number;\n                (<Writeable<Token>>(tokens[token.linkBack])).linkNext = tokens.length - 1;\n                commas.push(tokens.length - 1);\n\n            } else if (type === \"OPEN_BRACKET\") {\n                token.type = \"BRACKET\";\n\n            } else if (type === \"CLOSE_BRACKET\") {\n                // Remove the CLOSE_BRACKET\n                let suffix = (tokens.pop() as Token).text;\n                if (tokens.length > 0 && tokens[tokens.length - 1].type === \"NUMBER\") {\n                    const value = (tokens.pop() as Token).text;\n                    suffix = value + suffix;\n                    (<Writeable<Token>>(tokens[tokens.length - 1])).value = getNumber(value);\n                }\n                if (tokens.length === 0 || tokens[tokens.length - 1].type !== \"BRACKET\") {\n                    throw new Error(\"missing opening bracket\");\n                }\n                (<Writeable<Token>>(tokens[tokens.length - 1])).text += suffix;\n            }\n\n            continue;\n        }\n\n        match = cur.match(regexIdPrefix);\n        if (match) {\n            token.text = match[1];\n            offset += token.text.length;\n\n            if (Keywords.has(token.text)) {\n                token.type = \"KEYWORD\";\n                continue;\n            }\n\n            if (token.text.match(regexType)) {\n                token.type = \"TYPE\";\n                continue;\n            }\n\n            token.type = \"ID\";\n            continue;\n        }\n\n        match = cur.match(regexNumberPrefix);\n        if (match) {\n            token.text = match[1];\n            token.type = \"NUMBER\";\n            offset += token.text.length;\n            continue;\n        }\n\n        throw new Error(`unexpected token ${ JSON.stringify(cur[0]) } at position ${ offset }`);\n    }\n\n    return new TokenString(tokens.map((t) => Object.freeze(t)));\n}\n\n// Check only one of `allowed` is in `set`\nfunction allowSingle(set: ReadonlySet<string>, allowed: ReadonlySet<string>): void {\n    let included: Array<string> = [ ];\n    for (const key in allowed.keys()) {\n        if (set.has(key)) { included.push(key); }\n    }\n    if (included.length > 1) { throw new Error(`conflicting types: ${ included.join(\", \") }`); }\n}\n\n// Functions to process a Solidity Signature TokenString from left-to-right for...\n\n// ...the name with an optional type, returning the name\nfunction consumeName(type: string, tokens: TokenString): string {\n    if (tokens.peekKeyword(KwTypes)) {\n        const keyword = tokens.pop().text;\n        if (keyword !== type) {\n            throw new Error(`expected ${ type }, got ${ keyword }`);\n        }\n    }\n\n    return tokens.popType(\"ID\");\n}\n\n// ...all keywords matching allowed, returning the keywords\nfunction consumeKeywords(tokens: TokenString, allowed?: ReadonlySet<string>): ReadonlySet<string> {\n    const keywords: Set<string> = new Set();\n    while (true) {\n        const keyword = tokens.peekType(\"KEYWORD\");\n\n        if (keyword == null || (allowed && !allowed.has(keyword))) { break; }\n        tokens.pop();\n\n        if (keywords.has(keyword)) { throw new Error(`duplicate keywords: ${ JSON.stringify(keyword) }`); }\n        keywords.add(keyword);\n    }\n\n    return Object.freeze(keywords);\n}\n\n// ...all visibility keywords, returning the coalesced mutability\nfunction consumeMutability(tokens: TokenString): \"payable\" | \"nonpayable\" | \"view\" | \"pure\" {\n    let modifiers = consumeKeywords(tokens, KwVisib);\n\n    // Detect conflicting modifiers\n    allowSingle(modifiers, setify(\"constant payable nonpayable\".split(\" \")));\n    allowSingle(modifiers, setify(\"pure view payable nonpayable\".split(\" \")));\n\n    // Process mutability states\n    if (modifiers.has(\"view\")) { return \"view\"; }\n    if (modifiers.has(\"pure\")) { return \"pure\"; }\n    if (modifiers.has(\"payable\")) { return \"payable\"; }\n    if (modifiers.has(\"nonpayable\")) { return \"nonpayable\"; }\n\n    // Process legacy `constant` last\n    if (modifiers.has(\"constant\")) { return \"view\"; }\n\n    return \"nonpayable\";\n}\n\n// ...a parameter list, returning the ParamType list\nfunction consumeParams(tokens: TokenString, allowIndexed?: boolean): Array<ParamType> {\n    return tokens.popParams().map((t) => ParamType.from(t, allowIndexed));\n}\n\n// ...a gas limit, returning a BigNumber or null if none\nfunction consumeGas(tokens: TokenString): null | bigint {\n    if (tokens.peekType(\"AT\")) {\n        tokens.pop();\n        if (tokens.peekType(\"NUMBER\")) {\n            return getBigInt(tokens.pop().text);\n        }\n        throw new Error(\"invalid gas\");\n    }\n    return null;\n}\n\nfunction consumeEoi(tokens: TokenString): void {\n    if (tokens.length) {\n        throw new Error(`unexpected tokens: ${ tokens.toString() }`);\n    }\n}\n\nconst regexArrayType = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\n\nfunction verifyBasicType(type: string): string {\n    const match = type.match(regexType);\n    assertArgument(match, \"invalid type\", \"type\", type);\n    if (type === \"uint\") { return \"uint256\"; }\n    if (type === \"int\") { return \"int256\"; }\n\n    if (match[2]) {\n        // bytesXX\n        const length = parseInt(match[2]);\n        assertArgument(length !== 0 && length <= 32, \"invalid bytes length\", \"type\", type);\n\n    } else if (match[3]) {\n        // intXX or uintXX\n        const size = parseInt(match[3] as string);\n        assertArgument(size !== 0 && size <= 256 && (size % 8) === 0, \"invalid numeric width\", \"type\", type);\n    }\n\n    return type;\n}\n\n// Make the Fragment constructors effectively private\nconst _guard = { };\n\n\n/**\n *  When [walking](ParamType-walk) a [[ParamType]], this is called\n *  on each component.\n */\nexport type ParamTypeWalkFunc = (type: string, value: any) => any;\n\n/**\n *  When [walking asynchronously](ParamType-walkAsync) a [[ParamType]],\n *  this is called on each component.\n */\nexport type ParamTypeWalkAsyncFunc = (type: string, value: any) => any | Promise<any>;\n\nconst internal = Symbol.for(\"_ethers_internal\");\n\nconst ParamTypeInternal = \"_ParamTypeInternal\";\nconst ErrorFragmentInternal = \"_ErrorInternal\";\nconst EventFragmentInternal = \"_EventInternal\";\nconst ConstructorFragmentInternal = \"_ConstructorInternal\";\nconst FallbackFragmentInternal = \"_FallbackInternal\";\nconst FunctionFragmentInternal = \"_FunctionInternal\";\nconst StructFragmentInternal = \"_StructInternal\";\n\n/**\n *  Each input and output of a [[Fragment]] is an Array of **ParamType**.\n */\nexport class ParamType {\n\n    /**\n     *  The local name of the parameter (or ``\"\"`` if unbound)\n     */\n    readonly name!: string;\n\n    /**\n     *  The fully qualified type (e.g. ``\"address\"``, ``\"tuple(address)\"``,\n     *  ``\"uint256[3][]\"``)\n     */\n    readonly type!: string;\n\n    /**\n     *  The base type (e.g. ``\"address\"``, ``\"tuple\"``, ``\"array\"``)\n     */\n    readonly baseType!: string;\n\n    /**\n     *  True if the parameters is indexed.\n     *\n     *  For non-indexable types this is ``null``.\n     */\n    readonly indexed!: null | boolean;\n\n    /**\n     *  The components for the tuple.\n     *\n     *  For non-tuple types this is ``null``.\n     */\n    readonly components!: null | ReadonlyArray<ParamType>;\n\n    /**\n     *  The array length, or ``-1`` for dynamic-lengthed arrays.\n     *\n     *  For non-array types this is ``null``.\n     */\n    readonly arrayLength!: null | number;\n\n    /**\n     *  The type of each child in the array.\n     *\n     *  For non-array types this is ``null``.\n     */\n    readonly arrayChildren!: null | ParamType;\n\n\n    /**\n     *  @private\n     */\n    constructor(guard: any, name: string, type: string, baseType: string, indexed: null | boolean, components: null | ReadonlyArray<ParamType>, arrayLength: null | number, arrayChildren: null | ParamType) {\n        assertPrivate(guard, _guard, \"ParamType\");\n        Object.defineProperty(this, internal, { value: ParamTypeInternal });\n\n        if (components) { components = Object.freeze(components.slice()); }\n\n        if (baseType === \"array\") {\n            if (arrayLength == null || arrayChildren == null) {\n                throw new Error(\"\");\n            }\n        } else if (arrayLength != null || arrayChildren != null) {\n            throw new Error(\"\");\n        }\n\n        if (baseType === \"tuple\") {\n            if (components == null) { throw new Error(\"\"); }\n        } else if (components != null) {\n            throw new Error(\"\");\n        }\n\n        defineProperties<ParamType>(this, {\n            name, type, baseType, indexed, components, arrayLength, arrayChildren\n        });\n    }\n\n    /**\n     *  Return a string representation of this type.\n     *\n     *  For example,\n     *\n     *  ``sighash\" => \"(uint256,address)\"``\n     *\n     *  ``\"minimal\" => \"tuple(uint256,address) indexed\"``\n     *\n     *  ``\"full\" => \"tuple(uint256 foo, address bar) indexed baz\"``\n     */\n    format(format?: FormatType): string {\n        if (format == null) { format = \"sighash\"; }\n        if (format === \"json\") {\n            const name = this.name || \"\";\n\n            if (this.isArray()) {\n                const result = JSON.parse(this.arrayChildren.format(\"json\"));\n                result.name = name;\n                result.type += `[${ (this.arrayLength < 0 ? \"\": String(this.arrayLength)) }]`;\n                return JSON.stringify(result);\n            }\n\n            const result: any = {\n                type: ((this.baseType === \"tuple\") ? \"tuple\": this.type),\n                name\n            };\n\n\n            if (typeof(this.indexed) === \"boolean\") { result.indexed = this.indexed; }\n            if (this.isTuple()) {\n                result.components = this.components.map((c) => JSON.parse(c.format(format)));\n            }\n            return JSON.stringify(result);\n        }\n\n        let result = \"\";\n\n        // Array\n        if (this.isArray()) {\n            result += this.arrayChildren.format(format);\n            result += `[${ (this.arrayLength < 0 ? \"\": String(this.arrayLength)) }]`;\n        } else {\n            if (this.isTuple()) {\n                result += \"(\" + this.components.map(\n                    (comp) => comp.format(format)\n                ).join((format === \"full\") ? \", \": \",\") + \")\";\n            } else {\n                result += this.type;\n            }\n        }\n\n        if (format !== \"sighash\") {\n            if (this.indexed === true) { result += \" indexed\"; }\n            if (format === \"full\" && this.name) {\n                result += \" \" + this.name;\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     *  Returns true if %%this%% is an Array type.\n     *\n     *  This provides a type gaurd ensuring that [[arrayChildren]]\n     *  and [[arrayLength]] are non-null.\n     */\n    isArray(): this is (ParamType & { arrayChildren: ParamType, arrayLength: number }) {\n        return (this.baseType === \"array\")\n    }\n\n    /**\n     *  Returns true if %%this%% is a Tuple type.\n     *\n     *  This provides a type gaurd ensuring that [[components]]\n     *  is non-null.\n     */\n    isTuple(): this is (ParamType & { components: ReadonlyArray<ParamType> }) {\n        return (this.baseType === \"tuple\");\n    }\n\n    /**\n     *  Returns true if %%this%% is an Indexable type.\n     *\n     *  This provides a type gaurd ensuring that [[indexed]]\n     *  is non-null.\n     */\n    isIndexable(): this is (ParamType & { indexed: boolean }) {\n        return (this.indexed != null);\n    }\n\n    /**\n     *  Walks the **ParamType** with %%value%%, calling %%process%%\n     *  on each type, destructing the %%value%% recursively.\n     */\n    walk(value: any, process: ParamTypeWalkFunc): any {\n        if (this.isArray()) {\n            if (!Array.isArray(value)) { throw new Error(\"invalid array value\"); }\n            if (this.arrayLength !== -1 && value.length !== this.arrayLength) {\n                throw new Error(\"array is wrong length\");\n            }\n            const _this = this;\n            return value.map((v) => (_this.arrayChildren.walk(v, process)));\n        }\n\n        if (this.isTuple()) {\n            if (!Array.isArray(value)) { throw new Error(\"invalid tuple value\"); }\n            if (value.length !== this.components.length) {\n                throw new Error(\"array is wrong length\");\n            }\n            const _this = this;\n            return value.map((v, i) => (_this.components[i].walk(v, process)));\n        }\n\n        return process(this.type, value);\n    }\n\n    #walkAsync(promises: Array<Promise<void>>, value: any, process: ParamTypeWalkAsyncFunc, setValue: (value: any) => void): void {\n\n        if (this.isArray()) {\n            if (!Array.isArray(value)) { throw new Error(\"invalid array value\"); }\n            if (this.arrayLength !== -1 && value.length !== this.arrayLength) {\n                throw new Error(\"array is wrong length\");\n            }\n            const childType = this.arrayChildren;\n\n            const result = value.slice();\n            result.forEach((value, index) => {\n                childType.#walkAsync(promises, value, process, (value: any) => {\n                    result[index] = value;\n                });\n            });\n            setValue(result);\n            return;\n        }\n\n        if (this.isTuple()) {\n            const components = this.components;\n\n            // Convert the object into an array\n            let result: Array<any>;\n            if (Array.isArray(value)) {\n                result = value.slice();\n\n            } else {\n                if (value == null || typeof(value) !== \"object\") {\n                    throw new Error(\"invalid tuple value\");\n                }\n\n                result = components.map((param) => {\n                    if (!param.name) { throw new Error(\"cannot use object value with unnamed components\"); }\n                    if (!(param.name in value)) {\n                        throw new Error(`missing value for component ${ param.name }`);\n                    }\n                    return value[param.name];\n                });\n            }\n\n            if (result.length !== this.components.length) {\n                throw new Error(\"array is wrong length\");\n            }\n\n            result.forEach((value, index) => {\n                components[index].#walkAsync(promises, value, process, (value: any) => {\n                    result[index] = value;\n                });\n            });\n            setValue(result);\n            return;\n        }\n\n        const result = process(this.type, value);\n        if (result.then) {\n            promises.push((async function() { setValue(await result); })());\n        } else {\n            setValue(result);\n        }\n    }\n\n    /**\n     *  Walks the **ParamType** with %%value%%, asynchronously calling\n     *  %%process%% on each type, destructing the %%value%% recursively.\n     *\n     *  This can be used to resolve ENS naes by walking and resolving each\n     *  ``\"address\"`` type.\n     */\n    async walkAsync(value: any, process: ParamTypeWalkAsyncFunc): Promise<any> {\n        const promises: Array<Promise<void>> = [ ];\n        const result: [ any ] = [ value ];\n        this.#walkAsync(promises, value, process, (value: any) => {\n            result[0] = value;\n        });\n        if (promises.length) { await Promise.all(promises); }\n        return result[0];\n    }\n\n    /**\n     *  Creates a new **ParamType** for %%obj%%.\n     *\n     *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,\n     *  otherwise the ``indexed`` keyword will throw an error.\n     */\n    static from(obj: any, allowIndexed?: boolean): ParamType {\n        if (ParamType.isParamType(obj)) { return obj; }\n\n        if (typeof(obj) === \"string\") {\n            try {\n                return ParamType.from(lex(obj), allowIndexed);\n            } catch (error) {\n                assertArgument(false, \"invalid param type\", \"obj\", obj);\n            }\n\n        } else if (obj instanceof TokenString) {\n            let type = \"\", baseType = \"\";\n            let comps: null | Array<ParamType> = null;\n\n            if (consumeKeywords(obj, setify([ \"tuple\" ])).has(\"tuple\") || obj.peekType(\"OPEN_PAREN\")) {\n                // Tuple\n                baseType = \"tuple\";\n                comps = obj.popParams().map((t) => ParamType.from(t));\n                type = `tuple(${ comps.map((c) => c.format()).join(\",\") })`;\n            } else {\n                // Normal\n                type = verifyBasicType(obj.popType(\"TYPE\"));\n                baseType = type;\n            }\n\n            // Check for Array\n            let arrayChildren: null | ParamType  = null;\n            let arrayLength: null | number = null;\n\n            while (obj.length && obj.peekType(\"BRACKET\")) {\n                const bracket = obj.pop(); //arrays[i];\n                arrayChildren = new ParamType(_guard, \"\", type, baseType, null, comps, arrayLength, arrayChildren);\n                arrayLength = bracket.value;\n                type += bracket.text;\n                baseType = \"array\";\n                comps = null;\n            }\n\n            let indexed: null | boolean = null;\n            const keywords = consumeKeywords(obj, KwModifiers);\n            if (keywords.has(\"indexed\")) {\n                if (!allowIndexed) { throw new Error(\"\"); }\n                indexed = true;\n            }\n\n            const name = (obj.peekType(\"ID\") ? obj.pop().text: \"\");\n\n            if (obj.length) { throw new Error(\"leftover tokens\"); }\n\n            return new ParamType(_guard, name, type, baseType, indexed, comps, arrayLength, arrayChildren);\n        }\n\n        const name = obj.name;\n        assertArgument(!name || (typeof(name) === \"string\" && name.match(regexId)),\n            \"invalid name\", \"obj.name\", name);\n\n        let indexed = obj.indexed;\n        if (indexed != null) {\n            assertArgument(allowIndexed, \"parameter cannot be indexed\", \"obj.indexed\", obj.indexed);\n            indexed = !!indexed;\n        }\n\n        let type = obj.type;\n\n        let arrayMatch = type.match(regexArrayType);\n        if (arrayMatch) {\n            const arrayLength = parseInt(arrayMatch[2] || \"-1\");\n            const arrayChildren = ParamType.from({\n                type: arrayMatch[1],\n                components: obj.components\n            });\n\n            return new ParamType(_guard, name || \"\", type, \"array\", indexed, null, arrayLength, arrayChildren);\n        }\n\n        if (type === \"tuple\" || type.startsWith(\"tuple(\"/* fix: ) */) || type.startsWith(\"(\" /* fix: ) */)) {\n            const comps = (obj.components != null) ? obj.components.map((c: any) => ParamType.from(c)): null;\n            const tuple = new ParamType(_guard, name || \"\", type, \"tuple\", indexed, comps, null, null);\n            // @TODO: use lexer to validate and normalize type\n            return tuple;\n        }\n\n        type = verifyBasicType(obj.type);\n\n        return new ParamType(_guard, name || \"\", type, type, indexed, null, null, null);\n    }\n\n    /**\n     *  Returns true if %%value%% is a **ParamType**.\n     */\n    static isParamType(value: any): value is ParamType {\n        return (value && value[internal] === ParamTypeInternal);\n    }\n}\n\n/**\n *  The type of a [[Fragment]].\n */\nexport type FragmentType = \"constructor\" | \"error\" | \"event\" | \"fallback\" | \"function\" | \"struct\";\n\n/**\n *  An abstract class to represent An individual fragment from a parse ABI.\n */\nexport abstract class Fragment {\n    /**\n     *  The type of the fragment.\n     */\n    readonly type!: FragmentType;\n\n    /**\n     *  The inputs for the fragment.\n     */\n    readonly inputs!: ReadonlyArray<ParamType>;\n\n    /**\n     *  @private\n     */\n    constructor(guard: any, type: FragmentType, inputs: ReadonlyArray<ParamType>) {\n        assertPrivate(guard, _guard, \"Fragment\");\n        inputs = Object.freeze(inputs.slice());\n        defineProperties<Fragment>(this, { type, inputs });\n    }\n\n    /**\n     *  Returns a string representation of this fragment as %%format%%.\n     */\n    abstract format(format?: FormatType): string;\n\n    /**\n     *  Creates a new **Fragment** for %%obj%%, wich can be any supported\n     *  ABI frgament type.\n     */\n    static from(obj: any): Fragment {\n        if (typeof(obj) === \"string\") {\n\n            // Try parsing JSON...\n            try {\n                Fragment.from(JSON.parse(obj));\n            } catch (e) { }\n\n            // ...otherwise, use the human-readable lexer\n            return Fragment.from(lex(obj));\n        }\n\n        if (obj instanceof TokenString) {\n            // Human-readable ABI (already lexed)\n\n            const type = obj.peekKeyword(KwTypes);\n\n            switch (type) {\n                case \"constructor\": return ConstructorFragment.from(obj);\n                case \"error\": return ErrorFragment.from(obj);\n                case \"event\": return EventFragment.from(obj);\n                case \"fallback\": case \"receive\":\n                    return FallbackFragment.from(obj);\n                case \"function\": return FunctionFragment.from(obj);\n                case \"struct\": return StructFragment.from(obj);\n            }\n\n        } else if (typeof(obj) === \"object\") {\n            // JSON ABI\n\n            switch (obj.type) {\n                case \"constructor\": return ConstructorFragment.from(obj);\n                case \"error\": return ErrorFragment.from(obj);\n                case \"event\": return EventFragment.from(obj);\n                case \"fallback\": case \"receive\":\n                    return FallbackFragment.from(obj);\n                case \"function\": return FunctionFragment.from(obj);\n                case \"struct\": return StructFragment.from(obj);\n            }\n\n            assert(false, `unsupported type: ${ obj.type }`, \"UNSUPPORTED_OPERATION\", {\n                operation: \"Fragment.from\"\n            });\n        }\n\n        assertArgument(false, \"unsupported frgament object\", \"obj\", obj);\n    }\n\n    /**\n     *  Returns true if %%value%% is a [[ConstructorFragment]].\n     */\n    static isConstructor(value: any): value is ConstructorFragment {\n        return ConstructorFragment.isFragment(value);\n    }\n\n    /**\n     *  Returns true if %%value%% is an [[ErrorFragment]].\n     */\n    static isError(value: any): value is ErrorFragment {\n        return ErrorFragment.isFragment(value);\n    }\n\n    /**\n     *  Returns true if %%value%% is an [[EventFragment]].\n     */\n    static isEvent(value: any): value is EventFragment {\n        return EventFragment.isFragment(value);\n    }\n\n    /**\n     *  Returns true if %%value%% is a [[FunctionFragment]].\n     */\n    static isFunction(value: any): value is FunctionFragment {\n        return FunctionFragment.isFragment(value);\n    }\n\n    /**\n     *  Returns true if %%value%% is a [[StructFragment]].\n     */\n    static isStruct(value: any): value is StructFragment {\n        return StructFragment.isFragment(value);\n    }\n}\n\n/**\n *  An abstract class to represent An individual fragment\n *  which has a name from a parse ABI.\n */\nexport abstract class NamedFragment extends Fragment {\n    /**\n     *  The name of the fragment.\n     */\n    readonly name!: string;\n\n    /**\n     *  @private\n     */\n    constructor(guard: any, type: FragmentType, name: string, inputs: ReadonlyArray<ParamType>) {\n        super(guard, type, inputs);\n        assertArgument(typeof(name) === \"string\" && name.match(regexId),\n            \"invalid identifier\", \"name\", name);\n        inputs = Object.freeze(inputs.slice());\n        defineProperties<NamedFragment>(this, { name });\n    }\n}\n\nfunction joinParams(format: FormatType, params: ReadonlyArray<ParamType>): string { \n    return \"(\" + params.map((p) => p.format(format)).join((format === \"full\") ? \", \": \",\") + \")\";\n}\n\n/**\n *  A Fragment which represents a //Custom Error//.\n */\nexport class ErrorFragment extends NamedFragment {\n    /**\n     *  @private\n     */\n    constructor(guard: any, name: string, inputs: ReadonlyArray<ParamType>) {\n        super(guard, \"error\", name, inputs);\n        Object.defineProperty(this, internal, { value: ErrorFragmentInternal });\n    }\n\n    /**\n     *  The Custom Error selector.\n     */\n    get selector(): string {\n        return id(this.format(\"sighash\")).substring(0, 10);\n    }\n\n    /**\n     *  Returns a string representation of this fragment as %%format%%.\n     */\n    format(format?: FormatType): string {\n        if (format == null) { format = \"sighash\"; }\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"error\",\n                name: this.name,\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),\n            });\n        }\n\n        const result: Array<string> = [ ];\n        if (format !== \"sighash\") { result.push(\"error\"); }\n        result.push(this.name + joinParams(format, this.inputs));\n        return result.join(\" \");\n    }\n\n    /**\n     *  Returns a new **ErrorFragment** for %%obj%%.\n     */\n    static from(obj: any): ErrorFragment {\n        if (ErrorFragment.isFragment(obj)) { return obj; }\n\n        if (typeof(obj) === \"string\") {\n            return ErrorFragment.from(lex(obj));\n\n        } else if (obj instanceof TokenString) {\n            const name = consumeName(\"error\", obj);\n            const inputs = consumeParams(obj);\n            consumeEoi(obj);\n\n            return new ErrorFragment(_guard, name, inputs);\n        }\n\n        return new ErrorFragment(_guard, obj.name,\n            obj.inputs ? obj.inputs.map(ParamType.from): [ ]);\n    }\n\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is an\n     *  **ErrorFragment**.\n     */\n    static isFragment(value: any): value is ErrorFragment {\n        return (value && value[internal] === ErrorFragmentInternal);\n    }\n}\n\n/**\n *  A Fragment which represents an Event.\n */\nexport class EventFragment extends NamedFragment {\n    /**\n     *  Whether this event is anonymous.\n     */\n    readonly anonymous!: boolean;\n\n    /**\n     *  @private\n     */\n    constructor(guard: any, name: string, inputs: ReadonlyArray<ParamType>, anonymous: boolean) {\n        super(guard, \"event\", name, inputs);\n        Object.defineProperty(this, internal, { value: EventFragmentInternal });\n        defineProperties<EventFragment>(this, { anonymous });\n    }\n\n    /**\n     *  The Event topic hash.\n     */\n    get topicHash(): string {\n        return id(this.format(\"sighash\"));\n    }\n\n    /**\n     *  Returns a string representation of this event as %%format%%.\n     */\n    format(format?: FormatType): string {\n        if (format == null) { format = \"sighash\"; }\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"event\",\n                anonymous: this.anonymous,\n                name: this.name,\n                inputs: this.inputs.map((i) => JSON.parse(i.format(format)))\n            });\n        }\n\n        const result: Array<string> = [ ];\n        if (format !== \"sighash\") { result.push(\"event\"); }\n        result.push(this.name + joinParams(format, this.inputs));\n        if (format !== \"sighash\" && this.anonymous) { result.push(\"anonymous\"); }\n        return result.join(\" \");\n    }\n\n    /**\n     *  Return the topic hash for an event with %%name%% and %%params%%.\n     */\n    static getTopicHash(name: string, params?: Array<any>): string {\n        params = (params || []).map((p) => ParamType.from(p));\n        const fragment = new EventFragment(_guard, name, params, false);\n        return fragment.topicHash;\n    }\n\n    /**\n     *  Returns a new **EventFragment** for %%obj%%.\n     */\n    static from(obj: any): EventFragment {\n        if (EventFragment.isFragment(obj)) { return obj; }\n\n        if (typeof(obj) === \"string\") {\n            try {\n                return EventFragment.from(lex(obj));\n            } catch (error) {\n                assertArgument(false, \"invalid event fragment\", \"obj\", obj);\n            }\n\n        } else if (obj instanceof TokenString) {\n            const name = consumeName(\"event\", obj);\n            const inputs = consumeParams(obj, true);\n            const anonymous = !!consumeKeywords(obj, setify([ \"anonymous\" ])).has(\"anonymous\");\n            consumeEoi(obj);\n\n            return new EventFragment(_guard, name, inputs, anonymous);\n        }\n\n        return new EventFragment(_guard, obj.name,\n            obj.inputs ? obj.inputs.map((p: any) => ParamType.from(p, true)): [ ], !!obj.anonymous);\n    }\n\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is an\n     *  **EventFragment**.\n     */\n    static isFragment(value: any): value is EventFragment {\n        return (value && value[internal] === EventFragmentInternal);\n    }\n}\n\n/**\n *  A Fragment which represents a constructor.\n */\nexport class ConstructorFragment extends Fragment {\n\n    /**\n     *  Whether the constructor can receive an endowment.\n     */\n    readonly payable!: boolean;\n\n    /**\n     *  The recommended gas limit for deployment or ``null``.\n     */\n    readonly gas!: null | bigint;\n\n    /**\n     *  @private\n     */\n    constructor(guard: any, type: FragmentType, inputs: ReadonlyArray<ParamType>, payable: boolean, gas: null | bigint) {\n        super(guard, type, inputs);\n        Object.defineProperty(this, internal, { value: ConstructorFragmentInternal });\n        defineProperties<ConstructorFragment>(this, { payable, gas });\n    }\n\n    /**\n     *  Returns a string representation of this constructor as %%format%%.\n     */\n    format(format?: FormatType): string {\n        assert(format != null && format !== \"sighash\", \"cannot format a constructor for sighash\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"format(sighash)\" });\n\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"constructor\",\n                stateMutability: (this.payable ? \"payable\": \"undefined\"),\n                payable: this.payable,\n                gas: ((this.gas != null) ? this.gas: undefined),\n                inputs: this.inputs.map((i) => JSON.parse(i.format(format)))\n            });\n        }\n\n        const result = [ `constructor${ joinParams(format, this.inputs) }` ];\n        if (this.payable) { result.push(\"payable\"); }\n        if (this.gas != null) { result.push(`@${ this.gas.toString() }`); }\n        return result.join(\" \");\n    }\n\n    /**\n     *  Returns a new **ConstructorFragment** for %%obj%%.\n     */\n    static from(obj: any): ConstructorFragment {\n        if (ConstructorFragment.isFragment(obj)) { return obj; }\n\n        if (typeof(obj) === \"string\") {\n            try {\n                return ConstructorFragment.from(lex(obj));\n            } catch (error) {\n                assertArgument(false, \"invalid constuctor fragment\", \"obj\", obj);\n            }\n\n        } else if (obj instanceof TokenString) {\n            consumeKeywords(obj, setify([ \"constructor\" ]));\n            const inputs = consumeParams(obj);\n            const payable = !!consumeKeywords(obj, KwVisibDeploy).has(\"payable\");\n            const gas = consumeGas(obj);\n            consumeEoi(obj);\n\n            return new ConstructorFragment(_guard, \"constructor\", inputs, payable, gas);\n        }\n\n        return new ConstructorFragment(_guard, \"constructor\",\n            obj.inputs ? obj.inputs.map(ParamType.from): [ ],\n            !!obj.payable, (obj.gas != null) ? obj.gas: null);\n    }\n\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **ConstructorFragment**.\n     */\n    static isFragment(value: any): value is ConstructorFragment {\n        return (value && value[internal] === ConstructorFragmentInternal);\n    }\n}\n\n/**\n *  A Fragment which represents a method.\n */\nexport class FallbackFragment extends Fragment {\n\n    /**\n     *  If the function can be sent value during invocation.\n     */\n    readonly payable!: boolean;\n\n    constructor(guard: any, inputs: ReadonlyArray<ParamType>, payable: boolean) {\n        super(guard, \"fallback\", inputs);\n        Object.defineProperty(this, internal, { value: FallbackFragmentInternal });\n        defineProperties<FallbackFragment>(this, { payable });\n    }\n\n    /**\n     *  Returns a string representation of this fallback as %%format%%.\n     */\n    format(format?: FormatType): string {\n        const type = ((this.inputs.length === 0) ? \"receive\": \"fallback\");\n\n        if (format === \"json\") {\n            const stateMutability = (this.payable ? \"payable\": \"nonpayable\");\n            return JSON.stringify({ type, stateMutability });\n        }\n\n        return `${ type }()${ this.payable ? \" payable\": \"\" }`;\n    }\n\n    /**\n     *  Returns a new **FallbackFragment** for %%obj%%.\n     */\n    static from(obj: any): FallbackFragment {\n        if (FallbackFragment.isFragment(obj)) { return obj; }\n\n        if (typeof(obj) === \"string\") {\n            try {\n                return FallbackFragment.from(lex(obj));\n            } catch (error) {\n                assertArgument(false, \"invalid fallback fragment\", \"obj\", obj);\n            }\n\n        } else if (obj instanceof TokenString) {\n            const errorObj = obj.toString();\n\n            const topIsValid = obj.peekKeyword(setify([ \"fallback\", \"receive\" ]));\n            assertArgument(topIsValid, \"type must be fallback or receive\", \"obj\", errorObj);\n\n            const type = obj.popKeyword(setify([ \"fallback\", \"receive\" ]));\n\n            // receive()\n            if (type === \"receive\") {\n                const inputs = consumeParams(obj);\n                assertArgument(inputs.length === 0, `receive cannot have arguments`, \"obj.inputs\", inputs);\n                consumeKeywords(obj, setify([ \"payable\" ]));\n                consumeEoi(obj);\n                return new FallbackFragment(_guard, [ ], true);\n            }\n\n            // fallback() [payable]\n            // fallback(bytes) [payable] returns (bytes)\n            let inputs = consumeParams(obj);\n            if (inputs.length) {\n                assertArgument(inputs.length === 1 && inputs[0].type === \"bytes\",\n                    \"invalid fallback inputs\", \"obj.inputs\",\n                    inputs.map((i) => i.format(\"minimal\")).join(\", \"));\n            } else {\n                inputs = [ ParamType.from(\"bytes\") ];\n            }\n\n            const mutability = consumeMutability(obj);\n            assertArgument(mutability === \"nonpayable\" || mutability === \"payable\", \"fallback cannot be constants\", \"obj.stateMutability\", mutability);\n\n            if (consumeKeywords(obj, setify([ \"returns\" ])).has(\"returns\")) {\n                const outputs = consumeParams(obj);\n                assertArgument(outputs.length === 1 && outputs[0].type === \"bytes\",\n                    \"invalid fallback outputs\", \"obj.outputs\",\n                    outputs.map((i) => i.format(\"minimal\")).join(\", \"));\n            }\n\n            consumeEoi(obj);\n\n            return new FallbackFragment(_guard, inputs, mutability === \"payable\");\n        }\n\n        if (obj.type === \"receive\") {\n            return new FallbackFragment(_guard, [ ], true);\n        }\n\n        if (obj.type === \"fallback\") {\n            const inputs = [ ParamType.from(\"bytes\") ];\n            const payable = (obj.stateMutability === \"payable\");\n            return new FallbackFragment(_guard, inputs, payable);\n        }\n\n        assertArgument(false, \"invalid fallback description\", \"obj\", obj);\n    }\n\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **FallbackFragment**.\n     */\n    static isFragment(value: any): value is FallbackFragment {\n        return (value && value[internal] === FallbackFragmentInternal);\n    }\n}\n\n\n/**\n *  A Fragment which represents a method.\n */\nexport class FunctionFragment extends NamedFragment {\n    /**\n     *  If the function is constant (e.g. ``pure`` or ``view`` functions).\n     */\n    readonly constant!: boolean;\n\n    /**\n     *  The returned types for the result of calling this function.\n     */\n    readonly outputs!: ReadonlyArray<ParamType>;\n\n    /**\n     *  The state mutability (e.g. ``payable``, ``nonpayable``, ``view``\n     *  or ``pure``)\n     */\n    readonly stateMutability!: \"payable\" | \"nonpayable\" | \"view\" | \"pure\";\n\n    /**\n     *  If the function can be sent value during invocation.\n     */\n    readonly payable!: boolean;\n\n    /**\n     *  The recommended gas limit to send when calling this function.\n     */\n    readonly gas!: null | bigint;\n\n    /**\n     *  @private\n     */\n    constructor(guard: any, name: string, stateMutability: \"payable\" | \"nonpayable\" | \"view\" | \"pure\", inputs: ReadonlyArray<ParamType>, outputs: ReadonlyArray<ParamType>, gas: null | bigint) {\n        super(guard, \"function\", name, inputs);\n        Object.defineProperty(this, internal, { value: FunctionFragmentInternal });\n        outputs = Object.freeze(outputs.slice());\n        const constant = (stateMutability === \"view\" || stateMutability === \"pure\");\n        const payable = (stateMutability === \"payable\");\n        defineProperties<FunctionFragment>(this, { constant, gas, outputs, payable, stateMutability });\n    }\n\n    /**\n     *  The Function selector.\n     */\n    get selector(): string {\n        return id(this.format(\"sighash\")).substring(0, 10);\n    }\n\n    /**\n     *  Returns a string representation of this function as %%format%%.\n     */\n    format(format?: FormatType): string {\n        if (format == null) { format = \"sighash\"; }\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"function\",\n                name: this.name,\n                constant: this.constant,\n                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability: undefined),\n                payable: this.payable,\n                gas: ((this.gas != null) ? this.gas: undefined),\n                inputs: this.inputs.map((i) => JSON.parse(i.format(format))),\n                outputs: this.outputs.map((o) => JSON.parse(o.format(format))),\n            });\n        }\n\n        const result: Array<string> = [];\n\n        if (format !== \"sighash\") { result.push(\"function\"); }\n\n        result.push(this.name + joinParams(format, this.inputs));\n\n        if (format !== \"sighash\") {\n            if (this.stateMutability !== \"nonpayable\") {\n                result.push(this.stateMutability);\n            }\n\n            if (this.outputs && this.outputs.length) {\n                result.push(\"returns\");\n                result.push(joinParams(format, this.outputs));\n            }\n\n            if (this.gas != null) { result.push(`@${ this.gas.toString() }`); }\n        }\n        return result.join(\" \");\n    }\n\n    /**\n     *  Return the selector for a function with %%name%% and %%params%%.\n     */\n    static getSelector(name: string, params?: Array<any>): string {\n        params = (params || []).map((p) => ParamType.from(p));\n        const fragment = new FunctionFragment(_guard, name, \"view\", params, [ ], null);\n        return fragment.selector;\n    }\n\n    /**\n     *  Returns a new **FunctionFragment** for %%obj%%.\n     */\n    static from(obj: any): FunctionFragment {\n        if (FunctionFragment.isFragment(obj)) { return obj; }\n\n        if (typeof(obj) === \"string\") {\n            try {\n                return FunctionFragment.from(lex(obj));\n            } catch (error) {\n                assertArgument(false, \"invalid function fragment\", \"obj\", obj);\n            }\n\n        } else if (obj instanceof TokenString) {\n            const name = consumeName(\"function\", obj);\n            const inputs = consumeParams(obj);\n            const mutability = consumeMutability(obj);\n\n            let outputs: Array<ParamType> = [ ];\n            if (consumeKeywords(obj, setify([ \"returns\" ])).has(\"returns\")) {\n                outputs = consumeParams(obj);\n            }\n\n            const gas = consumeGas(obj);\n\n            consumeEoi(obj);\n\n            return new FunctionFragment(_guard, name, mutability, inputs, outputs, gas);\n        }\n\n        let stateMutability = obj.stateMutability;\n\n        // Use legacy Solidity ABI logic if stateMutability is missing\n        if (stateMutability == null) {\n            stateMutability = \"payable\";\n\n            if (typeof(obj.constant) === \"boolean\") {\n                stateMutability = \"view\";\n                if (!obj.constant) {\n                    stateMutability = \"payable\"\n                    if (typeof(obj.payable) === \"boolean\" && !obj.payable) {\n                        stateMutability = \"nonpayable\";\n                    }\n                }\n            } else if (typeof(obj.payable) === \"boolean\" && !obj.payable) {\n                stateMutability = \"nonpayable\";\n            }\n        }\n\n        // @TODO: verifyState for stateMutability (e.g. throw if\n        //        payable: false but stateMutability is \"nonpayable\")\n\n        return new FunctionFragment(_guard, obj.name, stateMutability,\n             obj.inputs ? obj.inputs.map(ParamType.from): [ ],\n             obj.outputs ? obj.outputs.map(ParamType.from): [ ],\n             (obj.gas != null) ? obj.gas: null);\n    }\n\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **FunctionFragment**.\n     */\n    static isFragment(value: any): value is FunctionFragment {\n        return (value && value[internal] === FunctionFragmentInternal);\n    }\n}\n\n/**\n *  A Fragment which represents a structure.\n */\nexport class StructFragment extends NamedFragment {\n\n    /**\n     *  @private\n     */\n    constructor(guard: any, name: string, inputs: ReadonlyArray<ParamType>) {\n        super(guard, \"struct\", name, inputs);\n        Object.defineProperty(this, internal, { value: StructFragmentInternal });\n    }\n\n    /**\n     *  Returns a string representation of this struct as %%format%%.\n     */\n    format(): string {\n        throw new Error(\"@TODO\");\n    }\n\n    /**\n     *  Returns a new **StructFragment** for %%obj%%.\n     */\n    static from(obj: any): StructFragment {\n        if (typeof(obj) === \"string\") {\n            try {\n                return StructFragment.from(lex(obj));\n            } catch (error) {\n                assertArgument(false, \"invalid struct fragment\", \"obj\", obj);\n            }\n\n        } else if (obj instanceof TokenString) {\n            const name = consumeName(\"struct\", obj);\n            const inputs = consumeParams(obj);\n            consumeEoi(obj);\n            return new StructFragment(_guard, name, inputs);\n        }\n\n        return new StructFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from): [ ]);\n    }\n\n// @TODO: fix this return type\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **StructFragment**.\n     */\n    static isFragment(value: any): value is FunctionFragment {\n        return (value && value[internal] === StructFragmentInternal);\n    }\n}\n\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}